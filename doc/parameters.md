# 設定パラメータについて

本ドキュメントでは、サンプルバッチの設定パラメータの以下の事項について記述します。

* パラメータ化した意図
* パラメータにより、ベンチマークがどのように影響を受けるか

## テストデータ生成に関するパラメータ

* min.date, max.date
  * テストデータ生成時、マスタの契約開始日、契約終了日は min.dateからmax.dateの範囲の日次が選ばれます。 
  * テストデータ生成時、通話履歴データの通話開始時刻はmin.dateからmax.dateの範囲の時刻が選ばれます。
* duplicate.phone.number.rate, expiration.date.rate, no.expiration.date.rate
  * マスタデータを生成時に使用されるパラメータです。
  * マスタデータの契約始日、契約終了日のバリエーションを規定します
  * duplicate.phone.number.rate, expiration.date.rate, no.expiration.date.rate をそれぞれa, b, c,とするとマスタデータの作成時、最初の(2a +  b + c)レコードについて、以下のパターンのデータを作成します。
    * 1つの電話番号にたいして契約終了にがあるレコードを1レコード、契約終了日がないレコードを1レコード、合計2aレコード
    * 契約終了日があるレコードをbレコード
    * 契約終了日がないレコードをcレコード  
  * (2a +  b + c)レコード以降は、 (2a +  b + c)レコードまでに生成した契約始日、契約終了日のバリエーションを繰り返し使用します。
  * 通常はnumber.of.contracts.recordsの値が(2a +  b + c)と等しくなるように、duplicate.phone.number.rate, expiration.date.rate, no.expiration.date.rateを設定してください。
  * number.of.contracts.recordsに非常に大きな値を指定するとメモリ不足が原因でテストデータの生成に失敗する可能性があります。このような場合、number.of.contracts.recordsが(2a +  b + c)の整数倍になるようにduplicate.phone.number.rate, expiration.date.rate, no.expiration.date.rateを指定することにより、テストデータ生成時のメモリ使用量を抑制できます。
* number.of.contracts.records, number.of.history.records それぞれマスタのレコード数、通話履歴のレコード数を表します。
  * テストデータ量と、料金計算バッチの処理データ量を規定するパラメータです。
  * 現状で指定可能な値の上限はInteger.MAX_VALUEです。
  * number.of.contracts.recordsとnumber.of.history.recordsの比により1契約あたりの通話履歴データ数が決まります。
  * テストデータ量を変えてテストする場合、データの性質を変えないために、number.of.contracts.records, number.of.history.recordsの比率を変えない値を指定してください。
  * とくに意図しない場合は、number.of.history.recordsの値は、number.of.contracts.recordsの1,000倍から10,000倍の値を指定してください。
  * この2つのパラメータにより、料金計算バッチ実行時のbillingテーブルinsert回数と、historyテーブルのupdate回数の割合が決まります。料金計算バッチは、billingテーブルinsert回数と比べてhistoryテーブルのupdate回数が圧倒的に多いことを想定していますが、insert回数の割合が多い場合のDBMSの挙動を試したい場合などに、number.of.history.recordsに小さい値を指定しても構いません。

## テストデータ生成時のデータの分布に関するパラメータ

* call.time.distribution, 
  - UNIFORMとLOGNORMALが指定可能です
    * UNIFORMが指定された場合、一様分布な通話時間が生成されます
    * LOGNORMALを指定された場合、対数正規分布な分布関数による乱数を用いて通話時間が生成されます
  - LOGNORMALを指定すると通話時間の分布が実際の通話時間の分布に近いものになります
  - UNIFORMとLOGNORMALのどちらを使用しても、ベンチマークの結果への影響はないはずです
* call.time.scale, call.time.shape
  - call.time.distribution=LOGNORMALのときの分布関数を決定するパラメータです。
  一般的な通話時間の分布となるような値がデフォルト値となっているため、通常は変更する必要はありません。
* recipient.phone.number.distribution, caller.phone.number.distribution
  - 通話履歴のテストデータを作成するときに発信者電話番号と受信者電話番号を選択するためのに使用する乱数生成器が従う分布関数を指定します。
  - UNIFORMとLOGNORMALが指定可能です
    * UNIFORMが指定された場合、一様分布の乱数生成器が使用されます。
    * LOGNORMALを指定された場合、対数正規分布の乱数生成器が使用されます。
  - 契約ごとの料金計算処理のトランザクションサイズに影響があります。
  - 次のようなケースを作りたいときに使用することを想定しています。
    * 一部の契約(電話番号)だけ巨大なトランザクションになってしまった場合のRDBMSの挙動を調べたい
    * 料金計算対象となる通話が1しかない契約が大量にあるようなケースで、RDBMSの性能を見たい。
  - LOGNOMARLを指定した場合、以下のパラメータで対数正規分布のscaleと、shapeを指定可能です。
    * recipient.phone.number.scale
    * recipient.phone.number.shape
    * caller.phone.number.scale
    * caller.phone.number.shape
  - 目的とした分布になるようにsacleとshapeの値を適当に選ぶ必要があります。scaleとshapeの値がデフォルト値でも問題ないケースも多いと考えます。
* 通常は recipient.phone.number.XXXとcaller.phone.number.distribution.XXXに同じ値を指定してください。

### UNIFORMが指定された場合の電話番号の分布の例

* 一様分布と、対数正規分布で分布にどのような違いが出るかを例示します。
* 例示する契約数を少なくしたいためnumber.of.contracts.recordsに極端に小さい値を指定してます。実際のベンチマークで使用するには不適切な値です。
* 最初のカラムが電話番号、次のカラムが頻度(当該電話番号を含むhistoryテーブルのレコード数)

#### UNIFORMを指定した場合
* 1万程度の頻度が多い
* 頻度が一様にならない理由
  - 契約期間が短い電話番号は選択されづらい
  - 乱数で選択した電話番号が通話開始時刻に契約期間外だった場合に、通話時刻開始時置く契約期間の電話番号がみつかるまで、電話番号をインクリメントして探すので、選ばれやすい電話番号が出てくる。


```
00000000065,147055
00000000073,86902
00000000081,57878
00000000089,36204
00000000026,26811
00000000075,24390
00000000083,21625
00000000091,20549
00000000099,20167
00000000095,20122
00000000034,20121
00000000032,20057
00000000085,20041
00000000093,19976
00000000097,19951
00000000023,19795
00000000048,19741
00000000012,11456
00000000027,10350
00000000020,10198
00000000049,10191
00000000000,10170
00000000035,10136
00000000002,10123
00000000013,10121
00000000004,10113
00000000030,10096
00000000042,10088
00000000037,10074
00000000021,10069
00000000001,10044
00000000043,10032
00000000040,10024
00000000006,10020
00000000045,10016
00000000003,10008
00000000044,10002
00000000038,9998
00000000014,9990
00000000041,9984
00000000018,9980
00000000007,9978
00000000036,9978
00000000039,9974
00000000017,9972
00000000015,9964
00000000005,9956
00000000009,9956
00000000010,9949
00000000028,9914
00000000019,9893
00000000016,9892
00000000008,9837
00000000046,9832
00000000029,9773
00000000011,8548
00000000087,3443
00000000024,3010
00000000069,1463
```

使用したパラメータ(関連するもののみ)
```
number.of.contracts.records=100
number.of.history.records=1000000
recipient.phone.number.distribution=UNIFORM
caller.phone.number.distribution=UNIFORM
```

#### LOGNORMALを指定した場合

* 頻度が40万を超える電話番号が2件ある一方過半の電話番号の頻度が2000未満

```
key, frequency
00000000027,405363
00000000048,404940
00000000095,16928
00000000000,15497
00000000003,14141
00000000030,12656
00000000089,9394
00000000026,7981
00000000008,7060
00000000081,7031
00000000019,6770
00000000005,6256
00000000075,5687
00000000097,4891
00000000091,4535
00000000042,4166
00000000073,4154
00000000039,3681
00000000004,3213
00000000083,3187
00000000010,2953
00000000017,2725
00000000021,2523
00000000009,2515
00000000046,2163
00000000099,2131
00000000045,1988
00000000049,1888
00000000036,1851
00000000001,1777
00000000002,1741
00000000035,1696
00000000032,1667
00000000018,1608
00000000012,1543
00000000038,1449
00000000044,1436
00000000085,1375
00000000034,1186
00000000037,1172
00000000028,1146
00000000011,1114
00000000014,1052
00000000015,1039
00000000006,1004
00000000007,994
00000000016,969
00000000065,969
00000000041,853
00000000093,819
00000000024,768
00000000023,764
00000000020,749
00000000043,741
00000000029,681
00000000013,654
00000000040,598
00000000087,118
00000000069,50
```


使用したパラメータ(関連するもののみ)
```
number.of.contracts.records=100
number.of.history.records=1000000
recipient.phone.number.distribution=LOGNORMAL
caller.phone.number.distribution=LOGNORMAL
```


## 料金計算バッチ実行に関するパラメータ

* target.month
  * 通話開始時刻がここで指定した時刻の通話履歴が処理対象の通話履歴になります。
  * 料金計算の対象月target.month は、min.date～max.dateの範囲に含まれる月から選択してください
    * max.dateが月の最終日でない場合は、max.dateの月はtarget.monthに指定不可
    * min.dateが月の最初の日でない場合は、min.dateの月はtarget.monthに指定不可
    * 現状パラメータチェックはしていませんが、プログラム設計時のこれを前提としています
  * target.month, min.date, max.dateの値により、計算対象となるデータ量が変化することに注意してください。
    * min.date～max.dateの間の期間が長いほど、計算対象となるデータは減ります。
    * target.monthで指定する月が新しいほど、計算対象となるデータが増えます。ただし、通常はベンチマーク結果に影響を与えるほど増加はしません。

* transaction.scope
  * WHOLE, CONTRACTのどちらかを指定
  * WHOLEを指定した場合、バッチ全体が1トランザクションとなる
    * オンラインアプリは別トランザクション
    * 正確には、thread.count で指定されたスレッド数だけトランザクションが生成され、処理完了時にすべてのトランザクションがまとめてcommit/rollbackされる。
    * WHOLEを指定した場合、DBMSやデータ量によっては、次のような事象が起きえる。
      * 処理に失敗する
      * 使い物にならないほど遅い
  * CONTRACTを指定した場合1契約(1電話番号)の処理が1トランザクションになる
    * 具体的には、処理対象の通話履歴レコードの料金を更新し、料金の合計金額をbillingテーブルにINSERTする
    * 多くのケースで正常に処理が終了し、WHOLEを指定した場合より処理時間が短くなることを期待できる。
    * テストデータ生成に関するパラメータにより1契約に紐付く通話履歴データが少ない場合、小さいトランザクションが多数発生することによる性能劣化があり得る。
    * 上項とは逆に、テストデータ生成に関するパラメータにより、1契約に紐付く通話履歴データが極端に大きい場合に次のような事象が起きえる。
      * 処理に失敗する
      * 使い物にならないほど遅い

* isolation.level
  * READ_COMMITTED, SERIALIZABLEを指定可能
  * バッチ、オンラインアプリの両方で指定されたアイソレーションレベルが使用される。
  * バッチ、オンラインアプリともに、アイソレーションレベルにREAD_COMMITTEDが指定されていることを前提としたコードになっている。
  * SERIALIZABLEを指定した場合、RDBMSにより厳しい条件を与えることになる。
  * RDBMSによっては、SERIALIZABLE指定時に極端に性能が悪化したり正常動作しないことがあり得る。
  * SERIALIZABLE指定時にRetry可能な例外が発生し得る。Retry可能な例外が発生した場合の動作は以下の通り。
    * transaction.scope=WHOLEの場合は、異常終了
    * transaction.scope=CONTRACTの場合は、トランザクションの最初からやりなおし。ただしすべてのケースを網羅はしていなく、異常終了する場合もあり得る。

* thread.count
  * 料金計算バッチの処理の主要部は多重処理されます。そのときの多重度を規定します。
  * 処理概要は以下の通り。
  * thread.countに大きな値を指定し、number.of.contracts.recordsに対してnumber.of.history.recordsの値が小さい場合、処理概要の1の処理が3の処理に追いつかなくなってボトルネックになることがあります。

```
1. 計算対象となる契約(電話番号)を抽出しキューに保存する。
   a. 処理対象のすべての契約をキューに保存したあとは、
      処理対象データがないことを示すマークをキューに保存する。
   b. この処理はシングルスレッドで処理される
2. thread.countで指定した数だけ、処理スレッドを起動する。
3. 各処理スレッドは以下の処理を繰り返す。
　a. キューから契約を取り出す。
    - キューが空の場合はキューに契約が入るのを待つ
    - 処理対象データがなくなった場合スレッドを終了する
  b. 当該契約の料金計算対象となる通話履歴をhistoryテーブルから抽出
  c. 抽出したhistoryテーブルの各レコードについて料金を計算し、計算した料金でレコードを更新する
  d. 同時に、当該契約に対する料金を積算する  
  e. すべてのレコードの処理完了後、billingテーブルに当該契約のレコードをInsertする
  f. transaction.scope=CONTRACTの場合、トランザクションをコミットする
4. 2.で起動したスレッドがすべて終了すると、トランザクションをコミットしてバッチを終了する。
```

* shared.connection
  * thread.countの項目の処理概要の1の処理のスレッドと、3の処理のスレッドで、JDBCコネクションを共有するのかを規定します
  * trueのときすべてのスレッドでJDBCコネクションを共有します。
  * falseの場合、スレッド毎にコネクションを用意されます
  * 特別な意図がある場合を除き、このパラメータにはfalseを指定してください
    * JDBCドライバはJDBCの仕様によりスレッドセーフです。ただし、ほとんどの実装で複数スレッドによる並列処理ができません。このため、thread.countに2以上の値を指定しても、thread.count=1と比べて性能が向上しません。
  * shared.connection=falseで、transaction.scope=WHOLEに指定した場合、スレッド毎にトランザクションが分かれるため、厳密にはtransaction.scope=WHOLEが実現できません。shared.connection=trueにするとバッチ処理全体を1トランザックションになります。

## オンラインアプリケーションに関するパラメータ 

* master.update.thread.count
  * 契約テーブルを更新するスレッドのスレッド数。 
* master.update.records.per.min
  * 各スレッドが1分間に何回契約テーブルの更新を行うのかを規定します
  * -1を指定すると連続で契約テーブルを更新します。
  * 1回の更新処理で、1レコードを更新します。1レコードの更新処理が1トランザクションになります。
  * 更新対象はランダムに選択され、料金計算バッチが処理中の契約レコードが更新される可能性もあります。

* master.insert.thread.count
  * 契約テーブルを追加するスレッドのスレッド数。 
* master.insert.records.per.min
  * 各スレッドが1分間に何回、契約テーブルにレコードを追加するのかを規定します。
  * -1を指定すると連続で契約テーブルにレコードを追加します。
  * 1回の追加処理で、1レコードを追加します。1レコードの更新処理が1トランザクションになります。
  * 追加されたレコードは料金計算バッチの処理対象外です

* history.update.thread.count
  * historyテーブルを更新するスレッドのスレッド数。 
* history.update.records.per.min
  * 各スレッドが1分間に何回、historyテーブルの更新を行うのかを規定します。
  * -1を指定すると連続でhistoryテーブルを更新します。
  * 1回の更新処理で、1レコードを更新します。1レコードの更新処理が1トランザクションになります。
  * 更新対象はランダムに選択され、料金計算バッチが処理中の契約レコードが更新される可能性もあります。

* history.insert.thread.count
  * historyテーブルを追加するスレッドのスレッド数。 
* history.insert.transaction.per.min, history.insert.records.per.transaction
  * 各スレッドが1分間に何回、historyテーブルにレコードを追加するのかを規定します。
  * -1を指定すると連続でhistoryテーブルにレコードを追加します。
  * 1回の追加処理で、history.insert.records.per.transactionで指定した数のレコードを1トランザクションで追加します。
  * 追加されたレコードは料金計算バッチの処理対象外です
    * 追加されるレコードの通話開始時刻は既存データの通話開始時刻より大きな値になります。

 
